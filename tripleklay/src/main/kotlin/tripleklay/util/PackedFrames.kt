package tripleklay.util

import euklid.f.Point
import euklid.f.Rectangle
import klay.core.Json
import klay.core.Tile
import klay.core.TileSource
import klay.scene.ImageLayer

/**
 * A frames implementation that uses a packed texture atlas and metadata generated by the
 * `FramePacker`.
 */
class PackedFrames(source: TileSource, protected val _width: Float, protected val _height: Float, protected val _frames: Array<PackedFrames.Frame>) : Frames {
    class Frame(val offset: Point, val bounds: Rectangle)

    constructor(source: TileSource, meta: Json.Object) : this(source, meta.getFloat("width")!!, meta.getFloat("height")!!, parseFrames(meta)) {}

    constructor(source: TileSource, meta: Array<FloatArray>) : this(source, meta[0][0], meta[0][1], parseFrames(meta)) {}

    protected lateinit var _tile: Tile

    init {
        if (source.isLoaded)
            _tile = source.tile()
        else
            source.tileAsync().onSuccess({ tile: Tile ->
                _tile = tile
            })
    }

    override fun width(): Float {
        return _width
    }

    override fun height(): Float {
        return _height
    }

    override fun count(): Int {
        return _frames.size
    }

    override fun bounds(index: Int): Rectangle {
        return _frames[index].bounds
    }

    override fun offset(index: Int): Point {
        return _frames[index].offset
    }

    override fun apply(index: Int, layer: ImageLayer) {
        val f = _frames[index]
        layer.setTile(_tile)
        layer.region = f.bounds
        layer.setTranslation(f.offset.x, f.offset.y)
    }

    companion object {

        /**
         * Parses JSON generated the `FramePacker` tool.
         */
        protected fun parseFrames(meta: Json.Object): Array<Frame> {
            // TODO: support skipping frames (right now we assume the frames in the json array are
            // exactly frames 0 to length-1)
            val jframes = meta.getArray("frames")
            val frames = arrayOfNulls<Frame>(jframes!!.length())
            for (ii in frames.indices) {
                val frame = jframes.getObject(ii)!!
                val off = frame.getArray("off", Float::class)!!
                val src = frame.getArray("src", Float::class)!!
                frames[frame.getInt("idx")!!] = Frame(
                        Point(off.get(0)!!, off.get(1)!!),
                        Rectangle(src.get(0)!!, src.get(1)!!, src.get(2)!!, src.get(3)!!))
            }
            return frames as Array<Frame>
        }

        /**
         * Parses custom float[][] array generated the `FramePacker` tool.
         */
        protected fun parseFrames(meta: Array<FloatArray>): Array<Frame> {
            val frames = arrayOfNulls<Frame>((meta.size - 1) / 2)
            var ii = 0
            var mm = 1
            while (ii < frames.size) {
                frames[ii] = Frame(Point(meta[mm][0], meta[mm++][1]),
                        Rectangle(meta[mm][0], meta[mm][1],
                                meta[mm][2], meta[mm++][3]))
                ii++
            }
            return frames as Array<Frame>
        }
    }
}
